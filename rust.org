* Rust

** 标记类型
标记类型用于提醒编译器采取相应的措施
*** 幽灵数据std::marker::PhantomData
#+begin_src rust
  pub struct PhantomData<T>
      where T: ?Sized;
#+end_src
PhantomData是~零~大小的类型用来标记那些行为像他们拥有一个~T~的东西

向您的类型添加~Phantomdata<T>~字段将告诉编译器 您的行为就像它存储了T类型的值一样


很多时候我们会遇到 ~类型~ 与 ~生命周期~ 在 ~逻辑~ 上与 ~结构~ 相关,但此时这种逻辑并不属于结构体字段的一部分

例如：
#+begin_src rust
  struct Iter<'a,T: 'a> {
      ptr: *const T,
      end: *const T,
  }
#+end_src

由于 ~<'a>~ 在结构中 ~未使用~ 所以实际上它是 ~无约束~ 的 , 所以我们必须有所标记来阐述这种关系 这便是 ~Phantomdata~ 的作用

#+begin_src rust
  use std::marker::Phantomdata;
  struct Iter<'a,T: 'a> {
      ptr: *const T,
      end: *const T,
      marker: Phantomdata<&'a T>,
  }
#+end_src

于是乎, 生命周期被 ~PhantomData<&'a T>~ 限定 
**** 绑定生命周期与所有权

例如标准库std的 ~LinkedList<T>~

因为裸指针不包含生命周期和所有权的信息


Phantomdata<Box<Node<T>,A>> 告诉编译器 ~LinkedList~ 与 ~Node~ 的所有权与生命周期是相关的 当 ~LinkedList~ 释放时, ~Node~ 也会释放
#+begin_src rust
  use std::ptr::NonNull;
  pub struct LinkedList<T> {
      head: Option<NonNull<Node<T>>>,
      tail: Option<NonNull<Node<T>>>,
      len: usize,
      alloc: A,
      marker: Phantomdata<Box<Node<T>,A>>,
  }
  struct Node<T> {
      next: Option<NonNull<Node<T>>>,
      prev: Option<NonNull<Node<T>>>,
      element: T,
  }
#+end_src

**** 未使用的类型数据FFI 
在这里 ~PhantomData<T>~ 被用来指明一个结构 ~绑定~ 了哪种类型的数据

标记外部指针的类型
#+begin_src rust
  struct LibraryBook<Book> {
      book_handle: *mut (),
      book_type: Phantomdata<Book>,
  }
#+end_src
