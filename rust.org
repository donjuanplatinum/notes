* Rust

** 标记类型
标记类型用于提醒编译器采取相应的措施
*** 幽灵数据std::marker::PhantomData
#+begin_src rust
  pub struct PhantomData<T>
      where T: ?Sized;
#+end_src
PhantomData是~零~大小的类型用来标记那些行为像他们拥有一个~T~的东西

向您的类型添加~Phantomdata<T>~字段将告诉编译器 您的行为就像它存储了T类型的值一样


很多时候我们会遇到 ~类型~ 与 ~生命周期~ 在 ~逻辑~ 上与 ~结构~ 相关,但此时这种逻辑并不属于结构体字段的一部分

例如：
#+begin_src rust
  struct Iter<'a,T: 'a> {
      ptr: *const T,
      end: *const T,
  }
#+end_src

由于 ~'a~ 在结构中 ~未使用~ 所以实际上它是 ~无约束~ 的 , 所以我们必须有所标记来阐述这种关系 这便是 ~Phantomdata~ 的作用

#+begin_src rust
  use std::marker::Phantomdata;
  struct Iter<'a,T: 'a> {
      ptr: *const T,
      end: *const T,
      marker: Phantomdata<&'a T>,
  }
#+end_src

于是乎, 生命周期被 ~PhantomData<&'a T>~ 限定 
**** 标记编译器无法推断的生命周期与所有权
#+begin_src rust
  use std::marker::Phantomdata;

  struct PtrStruct<T> {
      ptr: *mut T,
      marker: Phantomdata<T>,
  }
  impl<T> Ptrstruct<T> {
      fn new(t:T) -> Ptrstruct<T> {
	  let t = Box::new(t);
	  Ptrstruct{
	      ptr: Box::into_raw(t),
	      marker: Phantomdata,
	  }
  }
#+end_src
**** 未使用的生命周期参数
#+begin_src rust
  use std::marker::Phantomdata;
  struct Window<'a,T: 'a> {
      start: *const T,
      end: *const T,
      marker: Phantomdata<&'a T>,
  }
#+end_src
**** FFI
标记外部指针的类型
#+begin_src rust
  struct LibraryBook<Book> {
      book_handle: *mut (),
      book_type: Phantomdata<Book>,
  }
#+end_src
