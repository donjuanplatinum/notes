
* 算法
** 两数算法
| 算法             | 描述                   | 时间           | 空间 |
| [[#两数之和][1.两数之和]]       | 哈希表,数组            | O(N)           | O(N) |
| 2.[[#两数相加][两数相加]]       | 链表                   | 最长链表的长度 | O(1) |
| [[#最长不重复子字符串][3.无重复最长子串]] | 哈希表,滑动窗口,字符串 | O(N)           | 字符集大小一般为128 |
** leetcode
*** 两数之和
**** 描述
在给定数组中找到和等于给定结果的两个数的下标
**** 解法
使用结果-每个值 若差存在于哈希表中则直接取出
至于为什么要先插入 是为了预防匹配自己
**** code
#+begin_src rust
  ///两数之和
  ///```
  ///let a  = [2,3,4,1,7];
  ///let b  = algori::search::two_sum(&a,&11).unwrap();
  ///assert_eq!(b,(2,4));
  ///```
  pub fn two_sum<T>(array: &[T],target: &T) ->Result<(usize,usize),()>
  where T: std::hash::Hash + Eq + std::ops::Sub<Output=T> ,
  for<'a> &'a T: std::ops::Sub<&'a T, Output = T>,
  {
      use std::collections::HashMap;
      let mut map: HashMap<&T,usize> = HashMap::new();
      for (index,num) in array.iter().enumerate() {
	  let sub = target - num;
	  match map.get(&sub) {
	      Some(&j) => return Ok((j,index)),
	      None => {map.insert(num,index);},
	  }
      }
      Err(())
  }

#+end_src
*** 两数相加
**** 描述
两个倒序的单向链表相加 结果存储在新链表
1->2->3 + 2->9->1 = 3->1->5
321 + 192 = 513
**** 解法
使用一个进位存储进位
若一个链表到达了尽头 则当为0对待
**** code
#+begin_src rust
    impl Solution {    
      pub fn add_two_numbers(l1: Option<Box<ListNode>>, l2: Option<Box<ListNode>>) -> Option<Box<ListNode>> {    
	  let mut head = None;    
	  let mut current = &mut head;    
	  let mut carry = 0;    
	  while l1.is_some() || l2.is_some() || carry ==true {    
	      if let Some(mut node) =l1 {    
		  carry += node.val;    
		  l1 = node.next;    
	      }    
	      if let Some(mut node) =l2 {    
		  carry += node.val;    
		  l2 = node.next;    
	      }    
	      current = &mut current.insert(Box::new(ListeNode::new(carry % 10))).next    
	  }    
      }    
    }
#+end_src
*** 最长不重复子字符串
**** 描述
寻找字符串中的最长不重复子字符串
**** 解法
使用滑动窗口
并利用类似计数排序的方法将值保存
**** code
#+begin_src
  pub async fn substring(s: &str) -> usize {
    let s = s.as_bytes();
    let mut max = 0;
    let mut left = 0;
  //类似计数排序的方法而不用哈希表保存
    let mut window = [false;128];
  //开始滑动左边
    for (right,&c) in s.iter().enumerate() {
  //将字符串转换为ascii并映射在数组window
	let c = c as usize;
  //当数组window中存在这个字符时
	while window[c] {
  //摘除滑动窗口左边的值
	    window[s[left] as usize] = false;
  //左指针右滑
	    left += 1;
	}
  //映射值
	window[c] = true;
	max = max.max(right - left + 1);
    }
    max
}

#+end_src
